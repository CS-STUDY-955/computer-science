# Index

------ 초안 -------
1. 도서실에서 강목표로 책을 찾은 기억 -> 이것이 인덱스
2. 한 덩어리가 데이터가 저장되는 단위이며, 페이지라고 부름 -> 페이지는 mySQL 기본값 기준으로 16KB이며, 환경마다 다를 수 있음
3. 근데 다른 종류 도서를 다 합쳐도 문학도서 반도 안되서 문학도서는 찾기가 힘들어 -> 모든 페이지에 골고루 나눠지도록 분배 -> B트리 -> 기본 DB 인덱스 구조
4. 골고루 나눠놨는데 문학을 찾으려면 어디로 가야할지 알수가 없음 -> 강목표 대신 고유 값을 주고 정렬해서 골고루 나눠놓음 -> 클러스터링 인덱스 -> PK(Unique&NotNull)
5. 근데 누가 책 고유 값을 외우고 다녀 -> 이름으로 찾는 노래방 책자처럼 구분 -> 비클러스터링 인덱스 -> 중복되도 되긴하는데 Unique면 좋음
6. 쓰지도 않는 인덱스를 만들면 찾는 시간도 늘어나고 용량도 잡아먹기 때문에 자주 조인되거나 조건절에 들어오는 애들로만 만들어야됨
   - select 시간도 늘어나지만 DML이 수행될 때 페이지 분할이 발생할 수 있어 성능이 크게 저하될 수 있음
7. 성별같이 카디널리티가 작은 필드는 인덱스로 만들어봐야 풀 스캔이랑 크게 다르지 않으므로 만들지 않는게 좋음

![1](https://user-images.githubusercontent.com/50614241/215821070-d8e319eb-49a7-46e8-a324-72cc6b857b71.png)
![2](https://user-images.githubusercontent.com/50614241/215821074-b92b49e3-7db2-42f3-bc2f-5943c22bce56.png)
![3](https://user-images.githubusercontent.com/50614241/215821075-ae06cd8f-f1e7-40dc-8970-e27b6c62a68e.png)
![4](https://user-images.githubusercontent.com/50614241/215821079-319e1bc6-c54d-4cb5-bc96-385cece4177f.png)

# 프로세스
- 수행 중인 프로그램
- 컴퓨터 상에 수행 중인 프로그램의 인스턴스
- 처리기에 할당되어 수행될 수 있는 개체(entity)
- 프로그램 코드 및 관련데이터, 프로세스 제어 블록으로 구성된다고 볼 수 있다.
---

# 프로세스 제어 블록(PCB)
- 역할 : 스케줄링, 자원할당, 인터럽트 처리, 성능 측정과 분석 등
- 정보 :
    - 식별자 : 각 프로세스를 다른 프로세스로부터 구별해주는 유일한 식별자
    - 상태 : 프로세스가 수행중인지 나타냄. 수행/비수행 등
    - 우선순위 : 다른 프로세스들에 대해 상대적인 우선순위 수준
    - 프로그램 카운터 : 프로그램에서 다음에 수행될 명령어의 주소
    - 메모리 포인터: 프로세스와 연계된 프로그램 코드 및 데이터
    - 문맥 데이터 : 프로세스가 수행중일 때, 레지스터에 존재하는 데이터
    - 입출력 상태 정보 : 미해결 입출력 요청, 프로세스에 할당된 입출력 장치, 프로세스에 의해 사용중인 파일들의 리스트 등 
    - 어카운팅정보 : 사용된 시간 및 클록 시간, 시간제한, 계정정보 등
---

# 5-상태 모델(A Five-State Model)
<img src="https://t1.daumcdn.net/cfile/tistory/99AD494A5BFAA50E25" style="" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99AD494A5BFAA50E25" width="640" height="235" filename="5 상태 모델.jpg" filemime="image/jpeg">  <br>  
<img src="https://blog.kakaocdn.net/dn/b2LhUI/btrfw4fmC9a/GMNh4EhNyVqbzMrnBkwzK0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb2LhUI%2Fbtrfw4fmC9a%2FGMNh4EhNyVqbzMrnBkwzK0%2Fimg.png" data-origin-width="1496" data-origin-height="1030" data-filename="스크린샷 2021-09-19 오전 11.55.11.png" width="488" height="336" data-ke-mobilestyle="widthOrigin" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';">

- 생성(New) : 지금 막 생성되었지만, 운영체제에 의해 수행 가능한 프로세스 풀로 진입 허용되지 않은 프로세스. 아직 주기억장치에 저장되지 않는다.
- 준비(Ready) : 기회가 주어지면 수행할 준비가 되어있는 프로세스
- 수행(Running) : 현재 수행중인 프로세스. 단일처리기로 이루어진 컴퓨터에서는 임의 시점에 하나의 프로세스만이 수행 상태일 수 있다.
- 블록/대기(Blocked/Waiting) : 입출력 연산 완료 등과 같은 어떤 이벤트가 발생할 때 까지 수행될 수 없는 프로세스
- 종료(Exit) : 프로세스 수행이 중지되거나 중단되었기 때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스

<br>

* **Null -> 생성** : 어떤 프로그램을 수행하기 위해 새로운 프로세스가 생성된다.
* **생성 -> 준비** : 운영체제가 새로 생성된 프로세스를 받아들일 준비가 되었을 떄, 그 프로레스를 생성상태에서 준비상태로 전이시킨다. 대부분 시스템은 존재하는 프로세스 수에 재한을 두거나, 프로세스에게 할당되는 가상메모리 양을 제한한다. 제한 이유는 활성화된 프로세스가 너무 많아져 시스템 성능이 떨어지는 것을 방지하기 위함이다.
* **준비 -> 수행** : 수행할 프로세스를 선택할 때가 되면, 운영체제는 준비상태에 있는 프로세스들 중 하나를 선택한다. 이는 스케줄러 또는 디스패처의 임무이다.
* **수행 -> 종료** : 현재 수행중인 프로세스가 작업을 완료하거나 수행이 중단되면, 운영체제는 그 프로세스를 종료시킨다.
* **수행 -> 준비** : 수행중인 프로세스가 허용된 최대 처리 시간을 모두 사용했을 때 발생. 
* **수행 -> 블록** : 프로세스가 자원을 요구했는데 기다려야 한다면, 블록 상태로 전이된다. 
* **블록 -> 준비** : 블록상태에 있는 프로세스는 자신이 기다리던 이벤트가 발생하게되면 준비상태로 전이된다.
* **준비or블록** -> 종료 : 몇몇 시스템에서는 브모 프로세스가 자식 프로세스를 언제라도 종료시킬 수 있다. 또한, 부모프로세스가 종료되면, 그 프로세스와 관련된 모든 자식 프로세스들이 종료될 수 있다. 

---
# 문맥교환
CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
> System call이나 interrupt 발생해도 반드시 context switch가 발생하는 것은 아님.

1. 문맥 교환이 발생하지 않는 경우
    - user mode(프로세스 A)-> kernel mode -> user mode(프로세스 A)
        - system call이나 외부 interrupt가 발생한 경우
        - 일단 커널모드로 넘어가고 오랜 시간이 소요되지 않는다면 다시 기존 프로그램 실행
        - 이 경우 문맥교환이 발생하지 않는다.
2. 문맥 교환이 발생하는 경우
    - user mode(프로세스 A) -> kernel mode -> user mode(프로세스 B)
        - I/O system call이나 외부 timer interrupt가 발생한 경우
        - 시간이 오래걸리는 작업, 프로세스에 할당된 시간이 끝나는 경우
        - 이때 다른 프로세스로 변경하게 되고 이 경우 문맥교환이 발생한다.

## **프로세스 교환(Process Switching)**
수행중인 프로세스가 어느시점에 인터럽트되면, 운영체제는 다른 프로세스를 수행상태로 바꾸고, 그 프로세스에게 제어를 넘겨줌.
- 인터럽트 : 현재 명령어 수행의 외부 / 비동기적인 외부 사건에 반응
    - 클럭 인터럽트 : 자신에게 할당된 시간 초과
    - 입출력 인터럽트 : 입출력 오류
    - Memory Fault : 메모리 주소 참조 오류
- 트랩 : 현재 명령어 수행과 관련(불법적인 파일 접근시도) / 오류나 예외 상황 처리
- 수퍼바이저 호출 : 명시적 요청 / 운영체제 기능에 대한 호출
## **모드 교환(Mode Switching)**
- [사용자모드 vs. 커널모드](https://github.com/CS-STUDY-955/computer-science/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%BB%A4%EB%84%90%EB%AA%A8%EB%93%9C%EC%99%80%20%EC%9C%A0%EC%A0%80%EB%AA%A8%EB%93%9C.md)
- 운영체제 커널의 주요 기능
    - 프로세스 관리
    - 메모리 관리
    - 입출력 관리
    - 지원 기능

## 프로세스 상태 변경
모드전환은 프로세스 교환과 다른 개념
- 모드전환 : 현재 수행상태 프로세스 상태를 바꾸지 않고 수행 가능
- 프로세스 교환 순서
    1. 프로그램 카운터와 다른 레지스터들을 포함한 프로세스 문맥을 저장
    2. PCB 갱신 > 준비/블록/보류/종료 상태로 전환
    3. 프로세스의 PCB를 적잘한 큐에 옮김
    4. 다음에 수행할 다른 프로세스 선택
    5. 선택된 프로세스 제어블록 생신, 수행으로 변경
    6. 메모리 관련 자료구조 갱신(주소 변환에 따라 발생하지 않을 수도 있음)
    7. 선택된 프로세스가 이전 수행상태에서 사용했던 프로세서의 문맥을 복원
- 프로세스 교환은 모드 전환에 비해 상당히 많은 작업 요구

---

## 참고문헌
- Operating Systems Internals and Design Principles, William Stallings
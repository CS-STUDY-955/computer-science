# 디자인 패턴
## 디자인 패턴이란?
- 소프트웨어를 개발할 때 대부분은 기존에 만들었던 디자인을 재사용하게 됨
- 이 때 4명의 유명 개발자들은 23가지 소프트웨어 디자인 방법을 정리하여 이를 재사용하면 좋을 것 같다는 생각을 함
- 이렇게 탄생한 것이 흔히 디자인 패턴이라고 줄여부르는 GOF(GangOfFour) Design Pattern
- 효율적인 코드를 만들기 위한 방법론으로써, 반드시 지켜야한다고 생각하기 보단 자연스럽게 코드에 녹아들도록 하는 것이 좋음

## GOF 디자인 패턴의 종류
### 생성 패턴(Creational Patterns): 객체 생성에 관련된 패턴 5가지
1. 싱글턴(Singleton): 유일한 하나의 인스턴스를 보장하도록 하는 패턴
2. 팩토리 메서드(Factory Methods): 객체 생성 로직을 한 곳으로 모아놓고 선택하게 하는 패턴
3. 추상 팩토리 메서드(Abstract Factory): 서로 관련이 있는 객체들을 묶어서 팩토리 클래스로 만들고 이를 선택하게 하는 패턴
4. 빌더(Builder): 필수 값에 대해서는 생성자를, 선택적인 값들에 대해서는 메서드를 통해 인스턴스를 초기화하는 패턴
5. 프로토타입(Prototype): 프로토타입 패턴은 new 키워드를 사용하지 않고 객체를 복제해 생성하는 패턴

### 구조 패턴(Structural Pattern): 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴 7가지
1. 어댑터(Adapter): 한 인터페이스를 사용자가 원하는 인터페이스로 변환하는 패턴
2. 브리지(Bridge): 추상과 구현을 분리하여 결합도를 낮춘 패턴
3. 컴퍼지트(Composite): 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴
4. 데코레이터(Decorator): 소스를 변경하지 않고 기능을 확장하도록 하는 패턴
5. 퍼사드(Facade): 어떤 서브시스템 일련의 인터페이스에 대한 통합된 인터페이스를 제공하는 패턴
6. 플라이웨이트(Flyweight): 인스턴스를 가능한 한 공유하여 사용하는 패턴
7. 프록시(Proxy): 대리인이 대신 그 일을 처리하는 패턴

### 행위 패턴(Behavioral Pattern): 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴 11가지
1. 책임 연쇄(ChainofResponsibility): 요청을 받은 객체가 해당 요청을 해결할 수 없을 경우 연결된 다음 객체들에 전달하는 패턴
2. 커맨드(Command): 요청 자체를 캡슐화하여 파라미터로 넘기는 패턴
3. 인터프리터(Interpreter): 간단한 언어의 문법을 정의하고 해석하여 사용하는 패턴
4. 이터레이터(Iterator): 내부 표현은 보여주지 않고 순회하는 패턴
5. 중재자(Mediator): 객체 간 상호작용을 캡슐화하고 위임하여 처리하는 패턴
6. 메멘토(Memento): 상태 값을 미리 저장해 두었다가 복구하는 패턴
7. 옵저버(Observer): 상태가 변할 때 의존자들에게 알리고, 자동 업데이트하는 패턴
8. 스테이트(State): 객체 내부 상태에 따라서 행위를 변경하는 패턴
9. 전략(Strategy): 다양한 알고리즘 캡슐화하여 알고리즘 대체가 가능하도록 한 패턴
10. 템플릿 메서드(Template Methods): 알고리즘 골격의 구조를 정의한 패턴
11. 비지터(Visitor): 방문 공간이 방문자를 맞이할 때, 이후에 대한 행동을 방문자에게 위임하는 패턴

## 객체 지향 설계의 5대 원칙 SOLID
### 단일 책임 원칙(Single Responsibility Principle)
- 객체는 단 하나의 책임만 가져야 한다
- 계산기에 알람 기능 넣지 말아라

### 개방 폐쇄 원칙(Open-Close Principle)
- 확장에는 개방적이고 수정에는 폐쇄적이어야 한다
- 인터페이스 써서 추상화해라

### 리스코프 치환 원칙(Liskov Substitution Principle)
- 부모클래스와 자식클래스의 행위가 일관되어야 한다
- moveForward() override해서 후진기능 만들지 말아라

### 인터페이스 분리 원칙(Interface Segregation Principle)
- 하나의 거대한 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다
- Phone 인터페이스에 call(), message(), alarm(), calculator() 다 때려 넣지 말고 각 기능을 처리하는 인터페이스 만들어서 상속해라

### 의존 관계 역전 원칙(Dependency Inversion Principle)
- 추상성이 높은 클래스에 의존해야 한다
- 다른 객체 가져다 쓸 때 왠만하면 인터페이스로 사용해라
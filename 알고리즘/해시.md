# 해시(Hash)
![Hash_table](https://user-images.githubusercontent.com/63623597/232773004-85226980-2afa-4e40-800e-46cdee09313c.png)

## 개요
- 사전적 의미는 잘게 썰어 섞어놓는다는 뜻
- 해시란 데이터는 다루는 기법 중 하나로, 검색과 저장을 빠르게 하는 자료구조이다
- 자바 기준으로, ArrayList는 검색은 빠르지만, 데이터의 추가/삭제는 느리다.
- LinkedList는 데이터의 추가/삭제가 빠르지만, 반대로 데이터의 검색은 느리다.
- 해시는 내부적으로 배열을 사용하므로 검색이 빠르고, 추가/삭제 시에도 기존 데이터를 밀어내는 과정이 없으므로 그 속도가 빠른 편이다.
- 데이터를 저장할 때 Key-Value의 형태로 데이터를 저장하고, Key값이 배열의 인덱스로 저장되기 때문에 검색과 저장이 빠르게 일어난다.

## 해시 함수(Hash Function)
- Key값을 고정된 길이의 hash 값 또는 해시코드(Hash code)으로 변환하는 함수
- 해시 함수가 해시값을 생성하는 과정을 해싱이라고 한다.
- 대표적으로 division method가 있다.
  - 단, 2의 제곱수(2, 4, 8, 16, ...)로 나눌 경우, 그 수를 이진수로 바꾼 값의 이하 자릿수만 해쉬값에 영향을 주게 되므로 사용하지 않는 것이 좋다.
  - 충돌을 줄이려면 Key의 갯수의 3배가 m의 크기로 적당하다
  - 둘을 종합하면 Key의 갯수의 3배이며, 2의 제곱수에 근접한 소수가 좋다.

## 해시 테이블(Hash Table)
- 연관 배열 구조를 사용하여 Key와 Value를 저장하는 자료구조
  - 연관 배열 구조란, 키와 값 하나가 연관되어 키를 통해 연관되는 값을 찾을 수 있는 자료구조를 말한다.
- 장점
  - 구현 방식에 따라 중복 제거 가능
  - 배열의 인덱스로 접근하므로, 삽입, 삭제가 빠름
- 단점
  - 공간복잡도가 커짐
  - 충돌발생 가능
  - 순서가 뒤섞이므로, 순서가 중요하다면 어울리지 않는 방식

### java.util.HashTable VS java.util.HashMap
- 둘은 비슷하게 해시를 사용하여 Key-Value로 값을 저장한다는 공통점이 존재한다(두 클래스 모두 Map 인터페이스를 구현함)
- 차이점
  - Thread-safe: Hashtable은 syncronized로 선언되어 Thread-safe하지만, HashMap은 그렇지 않다.
  - Null 값: Hashtable은 Key값으로 Null을 허용하지만, HashMap은 그렇지 않다.
  - 일반적인 성능: HashMap은 보조 해시를 사용하기 때문에 일반적인 경우 Hashtable보다 빠르다.
  - 기타: Hashtable은 구현에 거의 변화가 없지만, HashMap은 지속적으로 개선중이다.

## 해시 충돌(Hash Collision)
- 해시 함수에 의해 서로 다른 키가 같은 해시가 되는 경우를 해시 충돌이라고 한다.
- 이는 해시의 성능에 영향을 끼치므로 최대한 이를 피하는 방식으로 구현하는 것이 좋다.
- 충돌을 대응하는 방식에는 크게 Chaining과 Open addressing이 있다

### Chaining
- 버켓(해시의 Key가 들어가는 공간. 일종의 index) 내에 연결리스트를 할당
- 해시충돌이 발생하면 해당하는 버켓의 리스트의 맨 마지막에 추가시킴
- 연결리스트만 사용하면 되므로 복잡한 계산식을 사용할 필요가 적다
- 단, 최악의 경우, 해시가 한곳에 몰리게 되면 시간복잡도가 O(n)에 가까워진다.

### Seperate Chaining(분리 연결법)
- Chaining에서 연결리스트를 자가균형 이진 탐색 트리로 바꾼 것
- 자바의 HashMap은 리스트의 길이가 8 이상이면 이 방식으로 바꾸도록 구현되어 있다고 함
- 시간 복잡도는 O(logN)이다.

### Open Addressing(개방 주소법)
- Chaining과 달리, 버켓이 차있으면 데이터의 주소값이 변하기 때문에 붙은 이름이다
- 충돌이 발생하면 다른 버켓에 데이터를 삽입한다.
- 대표적인 방법
  - 선형탐색: 다음, 또는 몇개를 건너 뛴 자리에 삽입. 순차 탐색을 한다.
  - 제곱탐색: 제곱만큼 건너뛰어 삽입한다
  - 이중 해시: 한 번 더 해시 함수를 적용한 값으로 해시를 저장한다. 연산량이 더 많아진다.
- 삽입, 삭제시 오버헤드가 적으며, 추가적인 저장공간이 필요 없다.
- 데이터의 수가 충분히 적다면 더 우수한 성능을 보이지만, 배열의 크기가 커지면 L1, L2 캐시 적중률이 낮아져 장점이 사라진다.


## 참고 자료
- https://velog.io/@xxhaileypark/Data-Structure-%ED%95%B4%EC%8B%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-hash-algorithm
- https://hsp1116.tistory.com/35
- https://devlog-wjdrbs96.tistory.com/253
# 부분집합

+ 집합에 포함된 원소들을 선택하는 것
+ 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것

<br>

### 1. 부분집합의 수
***
+ 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n
+ ex) { 1, 2, 3, 4 } => 2^4 = 16가지

<br>

### 2. 부분집합의 구현(재귀)
***
```java
// 자바
int[] input = {val1, val2, ...} // 배열
boolean[] isSelected; // 부분집합 포함/비포함 여부

void generateSubset(int cnt) { // cnt: 현재까지 처리한 원소 수
    if(cnt == N) { // N: 원소 개수
        /* 부분집합 완성 코드 */
        return; // 재귀 탈출
    }
    
    isSeleted[cnt] = true; // 현재 원소 포함하는 경우
    generateSubset(cnt+1);
    isSeleted[cnt] = false; // 현재 원소 포함하지 않는 경우
    generateSubset(cnt+1);
}
```

<br>

### 3. 비트 연산자
***
|연산자|설명|
|:--:|----|
| & |비트단위 AND <br> 원하는 자리를 선택, 방문되었는지 여부 판단 <br> ex) num = 01101, i  = 1; num & i << 3 => 01000|
| \| |비트단위 OR <br> 원하는 자리를 선택, flag 반영 <br> ex) num = 01001, i = 1; num \| 2 << i => 01101 |
| ^ | 비트단위 XOR <br> 같으면 0, 다르면 1 <br> ex) num1 = 0110, num2 = 1010; num1 ^ num2 = 1100 |
| ~ | 모든 비트 반전 |S
| <<| 비트열을 왼쪽으로 이동|
|>> | 비트열을 오른쪽으로 이동|

<br>

### 4. 부분집합 응용 - 바이너리 카운팅
***
+ 부분집합을 생성하기 위한 가장 자연스러운 방법
+ 바이너리 카운팅은 사전적 순서로 생성하기 위한 가장 간단한 방법
+ 메모리 측면에서 공간의 효율성을 높일 수 있다.
```java
// 원소가 30개 있는 경우
boolean[] isSelected = new boolean[30] // 30bytes
int select; // 4bytes
```
+ 원소 수에 해당하는 N개의 비트열을 이용한다.
+ n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.

|10진수|2진수|A,B,C,D|
|:--:|:----:|:-------:|
  0  | 0000 |    { }  |
  1  | 0001 |   {A}   |
  6  | 0110 |  {C, B} |
  9  | 1001 |  {D, A} |

```java
// 부분집합 - 바이너리 카운팅
arr = {'A', 'B', 'C', 'D'}
n = arr.length;
// 2^n번 반복 0부터 15까지 => (0000 ~ 1111)
for(int i = 0; i < (1 << n); i++) { 
	for(int j = 0; j < n; j++) {
        // 해당 자리 비트가 1이라면 선택됨을 의미
		if((i & (1 << j)) != 0) 
			System.out.print(arr[j]+" ");
	}
	System.out.println();
}
```




